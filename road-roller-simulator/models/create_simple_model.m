function create_simple_model()
% 创建简化的压路机模型（不使用Simulink图形界面）
% 
% 此函数创建一个基于MATLAB代码的简化模型
% 不依赖Simulink的图形化建模，更兼容不同版本
%
% 使用方法:
%   create_simple_model()

fprintf('\n====================================\n');
fprintf('  创建简化压路机模型\n');
fprintf('====================================\n\n');

fprintf('注意: 此模型不使用Simulink图形界面\n');
fprintf('      而是使用纯MATLAB代码实现\n');
fprintf('      更兼容，不需要特定Simulink版本\n\n');

% 创建模型参数文件
model_file = 'RoadRollerMathModel.m';

fprintf('正在创建模型文件: %s\n', model_file);

% 生成模型代码
model_code = create_model_code();

% 写入文件
fid = fopen(model_file, 'w');
if fid == -1
    error('无法创建模型文件');
end

fprintf(fid, '%s', model_code);
fclose(fid);

fprintf('✓ 模型文件创建成功!\n\n');

fprintf('使用方法:\n');
fprintf('  1. 调用 RoadRollerMathModel() 运行仿真\n');
fprintf('  2. 或使用 run_simulation() 函数\n\n');

fprintf('模型特点:\n');
fprintf('  - 完整的动力学方程\n');
fprintf('  - 发动机和传动系统\n');
fprintf('  - 振动系统\n');
fprintf('  - 压实度计算\n');
fprintf('  - 不依赖Simulink图形界面\n\n');

fprintf('====================================\n');

end

function code = create_model_code()
% 生成模型代码

code = [...
'function [t, y, results] = RoadRollerMathModel(duration, throttle, brake, vib_start_time)\n' ...
'%% 压路机数学模型\n' ...
'% 基于微分方程的压路机动力学仿真\n' ...
'%\n' ...
'% 输入:\n' ...
'%   duration - 仿真时长 (秒), 默认: 100\n' ...
'%   throttle - 油门 (0-1), 默认: 0.5\n' ...
'%   brake    - 制动 (0-1), 默认: 0\n' ...
'%   vib_start_time - 振动开启时间 (秒), 默认: 10\n' ...
'%\n' ...
'% 输出:\n' ...
'%   t       - 时间向量\n' ...
'%   y       - 状态矩阵 [velocity, position, compaction]\n' ...
'%   results - 结果结构体\n' ...
'\n' ...
'    %% 设置默认参数\n' ...
'    if nargin < 1, duration = 100; end\n' ...
'    if nargin < 2, throttle = 0.5; end\n' ...
'    if nargin < 3, brake = 0; end\n' ...
'    if nargin < 4, vib_start_time = 10; end\n' ...
'    \n' ...
'    %% 压路机参数\n' ...
'    params.mass = 12000;              % 质量 (kg)\n' ...
'    params.max_power = 150000;        % 最大功率 (W)\n' ...
'    params.efficiency = 0.85;         % 传动效率\n' ...
'    params.rolling_resistance = 0.05; % 滚动阻力系数\n' ...
'    params.vib_frequency = 30;        % 振动频率 (Hz)\n' ...
'    params.vib_amplitude = 50000;     % 激振力 (N)\n' ...
'    params.compaction_factor = 0.0001;% 压实系数\n' ...
'    \n' ...
'    %% 初始条件\n' ...
'    y0 = [0; 0; 0];  % [速度; 位置; 压实度]\n' ...
'    \n' ...
'    %% 求解微分方程\n' ...
'    options = odeset(''RelTol'', 1e-6, ''AbsTol'', 1e-9);\n' ...
'    [t, y] = ode45(@(t,y) dynamics(t, y, params, throttle, brake, vib_start_time), ...\n' ...
'                   [0 duration], y0, options);\n' ...
'    \n' ...
'    %% 计算振动力时间历程\n' ...
'    vibration_force = zeros(size(t));\n' ...
'    for i = 1:length(t)\n' ...
'        if t(i) >= vib_start_time\n' ...
'            vibration_force(i) = params.vib_amplitude * sin(2*pi*params.vib_frequency*t(i));\n' ...
'        end\n' ...
'    end\n' ...
'    \n' ...
'    %% 组织结果\n' ...
'    results = struct();\n' ...
'    results.time = t;\n' ...
'    results.velocity = y(:,1);\n' ...
'    results.position = y(:,2);\n' ...
'    results.compaction = y(:,3);\n' ...
'    results.vibration_force = vibration_force;\n' ...
'    \n' ...
'    % 计算性能指标\n' ...
'    results.metrics.max_velocity = max(abs(results.velocity));\n' ...
'    results.metrics.avg_velocity = mean(abs(results.velocity));\n' ...
'    results.metrics.total_distance = max(results.position) - min(results.position);\n' ...
'    results.metrics.final_compaction = results.compaction(end);\n' ...
'    if any(vibration_force ~= 0)\n' ...
'        results.metrics.avg_vibration = mean(abs(vibration_force(vibration_force~=0)));\n' ...
'    else\n' ...
'        results.metrics.avg_vibration = 0;\n' ...
'    end\n' ...
'    results.metrics.simulation_time = 0;  % 由调用者设置\n' ...
'    \n' ...
'    fprintf(''仿真完成!\\n'');\n' ...
'    fprintf(''最大速度: %.2f m/s\\n'', results.metrics.max_velocity);\n' ...
'    fprintf(''总距离: %.2f m\\n'', results.metrics.total_distance);\n' ...
'    fprintf(''最终压实度: %.2f\\n'', results.metrics.final_compaction);\n' ...
'    \n' ...
'end\n' ...
'\n' ...
'function dydt = dynamics(t, y, params, throttle, brake, vib_start_time)\n' ...
'%% 压路机动力学微分方程\n' ...
'    \n' ...
'    % 状态变量\n' ...
'    v = y(1);  % 速度\n' ...
'    % x = y(2);  % 位置 (不用于计算)\n' ...
'    % c = y(3);  % 压实度 (不用于速度计算)\n' ...
'    \n' ...
'    % 驱动力\n' ...
'    if v > 0.1\n' ...
'        F_drive = (throttle * params.max_power * params.efficiency) / v;\n' ...
'    else\n' ...
'        F_drive = throttle * params.max_power * params.efficiency * 10;  % 低速时的近似\n' ...
'    end\n' ...
'    \n' ...
'    % 阻力\n' ...
'    F_resistance = params.rolling_resistance * params.mass * 9.81;\n' ...
'    F_resistance = F_resistance + 0.5 * 1.225 * 5.0 * 0.4 * v^2;  % 空气阻力\n' ...
'    \n' ...
'    % 制动力\n' ...
'    F_brake = brake * 80000;  % 最大制动力 80kN\n' ...
'    \n' ...
'    % 振动力（作用在垂直方向，对水平运动有轻微影响）\n' ...
'    if t >= vib_start_time\n' ...
'        F_vib = params.vib_amplitude * sin(2*pi*params.vib_frequency*t);\n' ...
'    else\n' ...
'        F_vib = 0;\n' ...
'    end\n' ...
'    \n' ...
'    % 加速度\n' ...
'    a = (F_drive - F_resistance - F_brake) / params.mass;\n' ...
'    \n' ...
'    % 压实度变化率\n' ...
'    if t >= vib_start_time && abs(v) > 0.1\n' ...
'        dc_dt = params.compaction_factor * abs(F_vib) * abs(v);\n' ...
'    else\n' ...
'        dc_dt = 0;\n' ...
'    end\n' ...
'    \n' ...
'    % 返回导数\n' ...
'    dydt = [a; v; dc_dt];\n' ...
'    \n' ...
'end\n'];

end
